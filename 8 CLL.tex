\chapter{Classical Linear Logic}
\label{chap:execution}

Classical linear logic was introduced by Girard as the logic behind logic. It has a classical framework 
whilst also being constructive and was the first attempt at solving concurrency at a logical level. Here, 
we will build on the issue of concurrency by interpreting propositions as session types and extending 
CLL to CP, a session-typed process calculus introduced by Wadler. We will first explore CLL in it's 
usual form then combine it with session types to produce a prototypical concurrent language. \\

\noindent
In classical linear logic variables are denoted by capital letters $A, B, ...$ and the duals to these 
variables are denoted $\negg{A}, \negg{B}, ...$ where $\negg{A}$ (not A) is the negation of A and 
$\negg{\negg{A}} = A$. This negation is not present in intuitionistic linear logic since it retains the 
usual two sided sequent. However, in CLL we replace the two-sided sequent with a one-sided sequent, 
so a sequent in classical logic such as:
\begin{mathpar}
  A_1, A_2, ...,A_n \vdash B_1, B_2, ..., B_m \\
  \text{becomes} \quad \vdash \negg{A_1}, \negg{A_2}, ..., \negg{A_n}, B_1, B_1, ..., B_m
\end{mathpar}
This makes CLL slightly easier to read as we don't have to worry about propositions on the left-hand 
side of our sequent. We can see the use linear negation in our new one-sided sequent, as anything which 
would occur on the left-hand side of a classical sequent becomes a negation on the right-hand side of 
a CLL sequent. We also have that any proposition must be used exactly as many times as it appears. We 
cannot have some proposition $A$ and not make use of it, and similarly we cannot use it any more than 
once if it only appears once. \\

\section{Statics}

\begin{figure}[h]
  \begin{align*}
      Propositions \quad A \quad ::= \quad & X &\text{variable} \\
      & \negg{X} &\text{variable dual} \\
      & A \otimes B &\text{tensor} \\
      & A \parr B &\text{par} \\
      & A \oplus B &\text{plus} \\
      & A \with B &\text{with} \\
      & \ofc A &\text{of course} \\
      & \whynot A &\text{why not} \\
      & 1 &\text{tensor unit} \\
      & \bot &\text{par unit} \\
      & 0 &\text{plus unit} \\
      & \top &\text{with unit} \\
  \end{align*}
  \caption{Propositions for Classical Linear Logic}
  \label{fig: p cll}
\end{figure}

\noindent
Generally when researching the basics of classical linear logic, one may find the vending machine example which is 
widely used to describe the propositions of CLL in a way that is easy to understand. Say we have a vending machine 
which takes \pounds 1 coins and has the options of Tea or Coffee. If we see the tensor symbol on the machine: \emph{Tea} 
$\otimes$ \emph{Coffee}, then inserting \pounds 1 will give us both Tea and Coffee. However if we see \emph{Tea} $\with$ 
\emph{Coffee} then inserting \pounds 1 will give us a choice of either Tea or Coffee. If we can't decide what drink to 
have, then finding a vending machine which says \emph{Tea} $\oplus$ \emph{Coffee} will take our \pounds 1 and give us either 
Tea or Coffee making the decision for us. Par is not quite so easy to describe, if we stay with our vending machines then 
we would most likely see $\pounds 1 \ \parr$ \emph{Tea} which would imply that inserting \pounds 1 into the vending machine 
will then give us Tea. Having a term $A \parr B$ in classical linear logic is equivalent to having either $\negg{A} \multimap B$ 
or $\negg{B} \multimap A$ in linear logic. Essentially, we can have either \pounds 1 or Tea, but having one means we 
have given up the other.  \\

\noindent
Moving on to the exponential fragment, if we have a term $\ofc \pounds 1$ this would indicate that we have an unspecified 
number of \pounds 1 coins which we may use at the vending machine. We may also see a term $\whynot \pounds 1$ on any of 
these vending machines which would indicate that it is possible to use the machine any number of times by inserting multiple 
\pounds 1 coins, or none at all. Both of course ($\ofc$) and why not ($\whynot$) mean that whatever follows it can be used any 
number of times, or even never used at all. \\

\begin{figure}
  \begin{align*}
    \negg{(A \otimes B)} &= \negg{A} \parr \negg{B} & \negg{(A \parr B)} &= \negg{A} \otimes \negg{B} \\
    \negg{(A \oplus B)} &= \negg{A} \with \negg{B} & \negg{(A \with B)} &= \negg{A} \oplus \negg{B} \\
    \negg{(\ofc A)} &= \whynot \negg{A} & \negg{(\whynot A)} &= \ofc \negg{A} \\
    \negg{1} &= \bot & \negg{\bot} &= 1 \\
    \negg{0} &= \top & \negg{\top} &= 0
  \end{align*}
  \caption{Duals for Classical Linear Logic Propositions}
  \label{fig: duals}
\end{figure}

\noindent
For this report, we will modify these definitions slightly so they fit with our process calculus. \\

\noindent
Tensor, $A \otimes B$ represents multiplicative conjunction and means output A, then continue as B. The dual to tensor 
is par which represents multiplicative disjunction. We would read $A \parr B$ as input A, then continue as B. 
We have plus for additive disjunction so $A \oplus B$ means select either A or B.  Dual to this we have with, 
$A \with B$ meaning offer a choice between A and B. 
Our exponential component consists of of course, $\ofc A$ which means we have a server which can accept many 
copies of A, and why not, $\whynot A$ means we have a client who may request many copies of A. \\

\begin{figure}[h]
  \begin{align*}
    \Proc{P} ::= & \\
    & \Proc{P \mathbin{|} Q} & \text{parallel composition} \\
    & \Proc{\Link{x}{y}} & \text{link $\Name{x}$ with $\Name{y}$} \\
    & \Proc{\Out{y}{x}{P \mathbin{|} Q}} & \text{output $\Name{x}$ on channel $\Name{y}$} \\
    & \Proc{\In{y}{x}{P}} & \text{input $\Name{x}$ on channel $\Name{y}$} \\
    & \Proc{\Inl{x}{P}} & \text{left selection} \\
    & \Proc{\Inr{x}{P}} & \text{right selection} \\
    & \Proc{\Casep{x}{P}{Q}} & \text{choice} \\
    & \Proc{\New*{x}{}{P \mathbin{|} Q}} & \text{connect on channel $\Name{x}$} \\
    & \Proc{\whynot \Out{y}{x}{P}} & \text{client request} \\
    & \Proc{\ofc \In{y}{x}{P}} & \text{server accept} \\
    & \Proc{\Out{y}{\ }{P}} & \text{empty output} \\
    & \Proc{\In{y}{\ }{P}} & \text{empty input} \\
    & \Proc{\EmCase{x}} & \text{empty choice} \\
    & \Proc{P[\Name{x} / \Name{y}]} & \text{substitution}
  \end{align*}
  \caption{Process Calculus for Classical Linear Logic}
  \label{fig: p cp}
\end{figure}

\noindent
Classical linear logic naturally lends itself to parallelism, so we present the rules of CLL 
alongside a process calculus similar to $\pi$ calculus. 
A process $\Proc{P}$ can take on a few forms. Link says that we can connect two channels in 
such a way that any message delivered to $\Name{y}$ will be forwarded over $\Name{x}$ and vice verca.
For an output such as $\Proc{\Out{y}{x}{(P \mathbin{|} Q)}}$ we would output $\Name{x}$ on channel 
$\Name{y}$ then continue as $\Proc{P}$ and $\Proc{Q}$ in parallel. We have that $\Name{y}$ is bound in 
$\Proc{P}$, but is not bound in $\Proc{Q}$. For the input $\Proc{\In{y}{x}{P}}$, we input $\Name{x}$ 
on channel $\Name{y}$ then continue as $\Proc{P}$ where $\Name{y}$ is bound in $\Proc{P}$. 
In $\Proc{\New*{x}{}{P \mathbin{|} Q}}$, we connect processes $\Proc{P}$ and $\Proc{Q}$ on channel 
$\Name{x}$ where $\Name{x}$ is bound in both $\Proc{P}$ and $\Proc{Q}$. Server accept is just like 
input so for $\Proc{\In{\ofc y}{x}{P}}$, we would input $\Name{x}$ on channel $\Name{\ofc y}$ then 
continue as $\Proc{P}$ where $\Name{x}$ is bound in $\Proc{P}$. Similarly, for $\Proc{\Out{\whynot y}{x}{P}}$, 
we ouput $\Name{x}$ on channel $\Name{\whynot y}$ then continue as $\Proc{P}$ where $\Name{x}$ is 
bound in $\Proc{P}$. \\

% \section{Rules for CLL}

\noindent
We can now combine our process calculus with our propositions for CLL and present the rules for 
classical linear logic alongside their corresponding processes. Our typing judgements have the form 
$\IsProc{P}{\Gamma, \Name{x}: A}$ where $\Proc{P}$ is a process, $\Gamma$ is a type environment, 
$\Name{x}$ is a channel, and $A$ is a CLL proposition. This typing judgement means we have some process 
$\Proc{P}$ communicating along channel $\Name{x}$ obeying protocol $A$. Processes can communicate over 
multiple channels following different protocols, and as we saw in \ref{fig: p cp} the processes 
may also take on varying forms. \\

\begin{figure}[!]
  \begin{mathpar}
    \inferH{Axiom}{
    }{
      \IsProc{\Link{x}{y}}{\Name{x} : \negg{A}, \Name{y} : A}
    }\qquad
    \inferH{Cut}{
      \IsProc{P}{\Gamma, \Name{x} : \negg{A}} \\
      \IsProc{Q}{\Delta, \Name{x} : {A}}
    }{
      \IsProc{\New*{x}{}{P \mathbin{|} Q}}{\Gamma, \Delta}
    }\\

    \inferH{Tensor}{
        \IsProc{P}{\Gamma, \Name{x} : A} \\
        \IsProc{Q}{\Delta, \Name{y} : B}
    }{
        \IsProc{\Out{y}{x}{(P \mathbin{|} Q)}}{\Gamma, \Delta, \Name{y} : A \otimes B}
    } \qquad
    \inferH{Par}{
          \IsProc{P}{\Gamma, \Name{x} : A, \Name{y} : B} 
    }{
          \IsProc{\In{y}{x}{P}}{\Gamma, \Name{y} : A \parr B}
    }\\

    \inferH{Plus-L}{
      \IsProc{P}{\Gamma, \Name{x} : A}
    }{
      \IsProc{\Inl{x}{P}}{\Gamma, \Name{x} : A \oplus B}
    } \qquad
    \inferH{Plus-R}{
      \IsProc{P}{\Gamma, \Name{x} : B}
    }{
      \IsProc{\Inr{x}{P}}{\Gamma, \Name{x} : A \oplus B}
    }
    \qquad
    \inferH{With}{
      \IsProc{P}{\Gamma, \Name{x} : A} \\
      \IsProc{Q}{\Gamma, \Name{x} : B}
    }{
      \IsProc{\Casep{x}{P}{Q}}{\Gamma, \Name{x} : A \with B}
    }\\

    \inferH{Weakening}{
      \IsProc{P}{\Gamma}
    }{
      \IsProc{P}{\Gamma, \Name{x} : \whynot A}
    }\qquad
    \inferH{Contraction}{
      \IsProc{P}{\Gamma, \Name{x} : \whynot A, \Name{y} : \whynot A}
    }{
      \IsProc{P[\Name{x} / \Name{y}]}{\Gamma, \Name{x} : \whynot A}
    }\qquad
    \inferH{Dereliction}{
      \IsProc{P}{\Gamma, \Name{x} : A}
    }{
      \IsProc{\whynot \Out{y}{x}{P}}{\Gamma, \Name{y} : \whynot A}
    }\\

    \inferH{Promotion}{
      \IsProc{P}{\whynot \Gamma, \Name{x} : A}
    }{
      \IsProc{\ofc \In{y}{x}{P}}{\whynot \Gamma, \Name{y} : \ofc A}
    }\\

    \inferH{}{
    }{
      \IsProc{\Out{x}{\ }{P}}{\Name{x}: 1}
    }\qquad
    \inferH{}{
      \IsProc{P}{\Gamma}
    }{
      \IsProc{\In{x}{\ }{P}}{\Gamma, \Name{x}: \bot}
    }\qquad
    \inferH{}{
    }{
      \IsProc{\EmCase{x}}{\Gamma, \Name{x}: \top}
    }
  \end{mathpar}
  \caption{Static Rules for Classical Processes}
  \label{fig: r cll cp}
\end{figure}

\noindent
The \ruleref{Axiom} states that if we have some variable A, then we also have its dual $\negg{A}$. 
For the process calculus, we see that if we have two channels following dual protocols then any 
input along $\Name{x}$ is sent as output along $\Name{y}$, and vice verca.
The \ruleref{Cut} rule allows us to connect two processes together. As the protocols are dual, 
any transmissions and selections over one correspond with receives and choices over the other. This 
along with communication only via one channel ensures that the processes cannot get stuck. \\

\noindent
The \ruleref{Tensor} rule outputs a fresh channel x along y, then continues as P and Q in parallel.
As P and Q communicate over different channels, we have disjoint concurrency so the processes cannot 
communicate with each other. The new process, $\Proc{P \mathbin{|} Q}$ communicates over channel $\Name{y}$.
The rule \ruleref{Par} inputs A, then continues as B. This is known as connected concurrency as P can 
communicate along both $\Name{x}$ and $\Name{y}$. \\

\noindent
The rule \ruleref{Plus-L} indicates left selection, and similarly \ruleref{Plus-R} indicates right 
selection. The process $\Proc{\Inl{x}{P}}$ obeys protocol $A \oplus B$ by requesting the left option 
from a choice sent along $x$. The process for $\Proc{\Inr{x}{P}}$ is symmetric. 
The \ruleref{With} rule offers a choice between processes $\Proc{P}$ and $\Proc{Q}$. The new process 
$\Proc{\Casep{x}{P}{Q}}$ will receive a selection over channel $x$ and execute either $\Proc{P}$ or 
$\Proc{Q}$ accordingly. \\

\noindent
\ruleref{Weakening} lets us consider a process which doesn't communicate or follow a protocol to be 
a process which communicates along a channel $\Name{x}$ with protocol \whynot A. 
If a process $\Proc{P}$ communicates along two channels, both following the same protocol \whynot A, 
then we can use \ruleref{Contraction} to substitute one channel for another so $\Proc{P}$ communicates 
along only one channel following protocol \whynot A.
\ruleref{Dereliction} allows us to.

\section{Cut Reduction}

\noindent 
Just like in the simply typed lambda calculus, there are dynamic rules for classical linear logic. 
We have already seen the \ruleref{Cut} rule and the dynamics for CLL make use of this rule to simplify 
terms via cut reduction. These cut reduction rules also serve as a proof of preservation for CLL. We 
use the definition of preservation presented by Kokke, Montesi, and Peressotti \cite{kokke2019}. \\

\noindent
\textbf{Preservation:} If $\IsProc{P}{\Gamma}$ and $\Proc{P} \Longrightarrow \Proc{Q}$, then $\IsProc{Q}{\Gamma}$. 

\begin{figure}
  \begin{mathpar}
    \inferH{AxCut}{
      \inferH{}{
      }{
        \IsProc{\Link{x}{y}}{\Name{x}: \negg{A}, \Name{y}: A}
      }\\
      \inferH{}{
      }{
        \IsProc{P}{\Gamma, \Name{x}: A}
      }
    }{
      \IsProc{\New*{x}{}{\Link{x}{y} \mathbin{|} P}}{\Gamma, \Name{y}: A}
    } \quad \Longrightarrow_{axCut} \quad
    \IsProc{P[\Name{y} / \Name{x}]}{\Gamma, \Name{y}: A} \\\\

    \inferH{}{
      \inferH{}{
        \IsProc{P}{\Gamma, \Name{x} : \negg{A}} \\
        \IsProc{Q}{\Delta, \Name{y} : \negg{B}}
      }{
        \IsProc{\Out{y}{x}{(P \mathbin{|} Q)}}{\Gamma, \Delta, \Name{y} : \negg{A} \otimes \negg{B}} \\
      }\\
      \inferH{}{
        \IsProc{R}{\Theta, \Name{x} : A, \Name{y} : B}
      }{
        \IsProc{\In{y}{x}{R}}{\Theta, \Name{y} : A \parr B}
      }
    }{
      \IsProc{\New*{y}{}{\Out{y}{x}{(P \mathbin{|} Q)} \mathbin{|} \In{y}{x}{R}}}{\Gamma, \Delta, \Theta}
    } \quad \Longrightarrow_{\beta_{\otimes \parr}} \\

    \inferH{}{
      \inferH{}{
        \IsProc{P}{\Gamma, \Name{x} : \negg{A}} \\
        \IsProc{R}{\Theta, \Name{x} : A, \Name{y}: B}
      }{
        \IsProc{\New*{x}{}{P \mathbin{|} Q}}{\Gamma, \Theta, \Name{y} : B} \\
      }\\
      \inferH{}{
      }{
        \IsProc{Q}{\Delta, \Name{y} : \negg{B}}
      }
    }{
      \IsProc{\New*{y}{}{\New*{x}{}{P \mathbin{|} R} \mathbin{|} Q}}{\Gamma, \Delta, \Theta}
    }\\\\

    \inferH{}{
      \inferH{}{
        \IsProc{P}{\Gamma, \Name{x}: A}
      }{
        \IsProc{\Inl{x}{P}}{\Gamma, \Name{x}: A \oplus B}
      }\\
      \inferH{}{
        \IsProc{Q}{\Delta, \Name{x}: \negg{A}}\\
        \IsProc{R}{\Theta, \Name{x}: \negg{B}}
      }{
        \IsProc{\Casep{x}{Q}{R}}{\Delta, \Name{x}: A \with B}
      }
    }{
      \IsProc{\New*{x}{}{\Inl{x}{P} \mathbin{|} \Casep{x}{Q}{R}}}{\Gamma, \Delta}
    } \quad \Longrightarrow_{\beta_{\oplus \with}} \quad
    \inferH{}{
      \IsProc{P}{\Gamma, \Name{x}: A}\\
      \IsProc{Q}{\Delta, \Name{x}: \negg{A}}
    }{
      \IsProc{\New*{x}{}{P \mathbin{|} Q}}{\Gamma, \Delta}
    }\\\\

    \inferH{}{
      \inferH{}{
        \IsProc{P}{\whynot \Gamma, \Name{x}: A}
      }{
        \IsProc{\ofc \In{y}{x}{P}}{\whynot \Gamma, \Name{y}: \ofc A}
      }\\
      \inferH{}{
        \IsProc{Q}{\Delta, \Name{x}: \negg{A}}
      }{
        \IsProc{\whynot \Out{y}{x}{Q}}{\Delta, \Name{y}: \negg{\whynot A}}
      }
    }{
      \IsProc{\New*{y}{}{\ofc \In{y}{x}{P} \mathbin{|} \whynot \Out{y}{x}{Q}}}{\whynot \Gamma, \Delta}
    } \quad \Longrightarrow_{\beta_{\ofc \whynot}} \quad
    \inferH{}{
      \IsProc{P}{\whynot \Gamma, \Name{x}: A}\\
      \IsProc{Q}{\Delta, \Name{x}: \negg{A}}
    }{
      \IsProc{\New*{x}{}{P \mathbin{|} Q}}{\whynot \Gamma, \Delta}
    }\\\\

    \inferH{}{
      \inferH{}{
        \IsProc{P}{\whynot \Gamma, \Name{x}: A}
      }{
        \IsProc{\ofc \In{y}{x}{P}}{\whynot \Gamma, \Name{y}: \ofc A}
      }\\
      \inferH{}{
        \IsProc{Q}{\Delta}
      }{
        \IsProc{Q}{\Delta, \Name{x}: \negg{\whynot A}}
      }
    }{
      \IsProc{\New*{y}{}{\ofc \In{y}{x}{P} \mathbin{|} Q}}{\whynot \Gamma, \Delta}
    } \quad \Longrightarrow_{\beta_{\ofc W}} \quad
    \inferH{}{
      \IsProc{Q}{\Delta}
    }{
      \IsProc{Q}{\whynot \Gamma, \Delta}
    }\\\\

    \inferH{}{
      \inferH{}{
        \IsProc{P}{\whynot \Gamma, \Name{x}: A}
      }{
        \IsProc{\ofc \In{y}{x}{P}}{\whynot \Gamma, \Name{y}: \ofc A}
      }\\
      \inferH{}{
        \IsProc{Q}{\Delta, \Name{y}: \whynot A, \Name{z}: \whynot A}
      }{
        \IsProc{Q[\Name{y} / \Name{z}]}{\Delta, \Name{y}: \whynot A}
      }
    }{
      \IsProc{\New*{y}{}{\ofc \In{y}{x}{P} \mathbin{|} Q[\Name{y} / \Name{z}]}}{\whynot \Gamma, \Delta}
    }\quad \Longrightarrow_{\beta_{\ofc C}} \\

    \inferH{}{
      \inferH{}{
        \IsProc{P}{\whynot \Gamma, \Name{x}: A}
      }{
        \IsProc{\ofc \In{y}{x}{P}}{\whynot \Gamma, \Name{y}: \ofc A}
      }\\
      \inferH{}{
        \inferH{}{
          \IsProc{P'}{\whynot \Gamma', \Name{w}: A}
        }{
          \IsProc{\ofc \In{z}{w}{P}}{\whynot \Gamma', \Name{z}: \ofc A}
        }\\
        \IsProc{Q}{\Delta, \Name{y}: \negg{\whynot A}, \Name{z}: \negg{\whynot A}}
      }{
        \IsProc{\New*{z}{}{\ofc \In{z}{w}{P} \mathbin{|} Q}}{\whynot \Gamma', \Delta, \Name{x}: \negg{\whynot A}}
      }
    }{
      \inferH{}{
        \IsProc{\New*{y}{}{\ofc \In{y}{x}{P} \mathbin{|} \New*{z}{}{\ofc \In{z}{w}{P'} \mathbin{|} Q}}}{\whynot \Gamma, \whynot \Gamma', \Delta}
      }{
        \IsProc{\New*{y}{}{\ofc \In{y}{x}{P} \mathbin{|} \New*{z}{}{\ofc \In{z}{y}{P} \mathbin{|} Q}}}{\whynot \Gamma, \Delta}
      }
    }\\\\

    \inferH{}{
      \inferH{}{
        \IsProc{P}{\Gamma}
      }{
        \IsProc{\In{x}{\ }{P}}{\Gamma, \Name{x}: \bot}
      }\\
      \inferH{}{
      }{
        \IsProc{\Out{x}{\ }{Q}}{\Name{x}: 1}
      }
    }{
      \IsProc{\New*{x}{}{\ }\In{x}{\ }{P} \mathbin{|} \Out{x}{\ }{Q}}{\Gamma}
    }\quad \Longrightarrow_{\beta_{1 \bot}} \quad
    \IsProc{P}{\Gamma}
  \end{mathpar}
  \caption{Cut Reduction Rules for Classical Processes}
    \label{fig: cr cp}
\end{figure}


% -----------------------------------------------------------------------------
