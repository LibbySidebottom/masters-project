\chapter{Introduction}
\label{chap: intro}

% The problem - no one ever wrote any basic explanation on CLL so the literature on the subject is very 
% inaccessible. The goal - to introduce CLL in an accessible format and to provide a translation from the 
% Lambda Calculus to CLL.

\noindent
There is no lack of literature on classical linear logic, however almost all of it assumes a reasonable 
level of prior knowledge on the subject. This would not be a problem if someone had written down all the 
rules and explained the purpose of CLL. Unfortunately, no one thought to do such a thing and so the rules 
are taught to students by supervisors in a one-on-one setting. The aim of this report is to present 
the rules of classical linear logic such that someone who has no prior knowledge can come away knowing 
enough to approach more literature on the topic without feeling out of depth. We will then provide a 
translation from the simply typed lambda calculus into classical linear logic which has again been 
considered by many prominent figures, but never been written out in full. 

There are two forms of logic: classical logic, and constructive logic (also called intuitionistic logic). 
Statements in classical logic 
can be either true or false, and cannot be undetermined. A statement is true in classical logic if it 
is not false. On some level this makes sense as we may consider things to be either true or false, 
but we can have results in mathematics which are not proved to be true but aren't proved to be false 
either. A famous computer science theorem of this nature is the P vs. NP problem. It has neither 
been proven that P = NP or that P $\ne$ NP, but we cannot have uncertainty classical logic. However, as 
it is not proven that P $\ne$ NP then we can assume P = NP in classical logic. On the other hand, in 
constructive logic we can only accept as statement to be true if we have proved that it is true, 
and similarly we can only accept it is false if we have proved it to be. So, in constructive logic 
we can accept P vs. NP as an unsolved problem. This makes constructive logic stronger than classical 
logic as we can have ambiguous statements.

Our main topic is classical linear logic which was first presented by Girard as an extension of classical 
logic. Classical linear logic is a classical logic without structural rules. It is purely mathematical and has a 
number of applications in computer science, namely in reasoning about resources and resource usage, reasoning 
about ownership, and finally in communication. The latter is seen under the Curry-Howard isomorphism, and is 
the aspect we will be focusing on. 

The Curry-Howard isomorphism is a well known equivalence between mathematical proofs and computation. Here 
we use a variant of this found by Caires and Pfenning (*) with 
\begin{align*}
    \text{propositions }& \text{as session types,} \\
    \text{proofs } & \text{as processes,} \\
    \text{cut elimination } & \text{as computation.} 
\end{align*}

This variant equates classical linear logic with a process calculus similar 
to the $\pi$ calculus and allows us to model classical linear logic as a parallel programming language. 


In fact, Girard (*) said linear logic had a strong connection to parallel computation, 
specifically the multiplicative fragment being an asynchronous communication system.

exponentials allow us to add structural rules like contraction and weakening to some extent

% {\bf A compulsory chapter, of roughly $5$ pages}

% \noindent
% This chapter should describe the project context, and motivate each of
% the proposed aims and objectives.  Ideally, it is written at a fairly 
% high-level, and easily understood by a reader who is technically 
% competent but not an expert in the topic itself.

% In short, the goal is to answer three questions for the reader.  First, 
% what is the project topic, or problem being investigated?  Second, why 
% is the topic important, or rather why should the reader care about it?  
% For example, why there is a need for this project (e.g., lack of similar 
% software or deficiency in existing software), who will benefit from the 
% project and in what way (e.g., end-users, or software developers) what 
% work does the project build on and why is the selected approach either
% important and/or interesting (e.g., fills a gap in literature, applies
% results from another field to a new problem).  Finally, what are the 
% central challenges involved and why are they significant? 
 
% The chapter should conclude with a concise bullet point list that 
% summarises the aims and objectives.  For example:

% \begin{quote}
% \noindent
% The high-level objective of this project is to reduce the performance 
% gap between hardware and software implementations of modular arithmetic.  
% More specifically, the concrete aims are:

% \begin{enumerate}
% \item Research and survey literature on public-key cryptography and
%       identify the state of the art in exponentiation algorithms.
% \item Improve the state of the art algorithm so that it can be used
%       in an effective and flexible way on constrained devices.
% \item Implement a framework for describing exponentiation algorithms
%       and populate it with suitable examples from the literature on 
%       an ARM7 platform.
% \item Use the framework to perform a study of algorithm performance
%       in terms of time and space, and show the proposed improvements
%       are worthwhile.
% \end{enumerate}
% \end{quote}

% -----------------------------------------------------------------------------